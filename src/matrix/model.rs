use bevy::render::mesh::{Mesh, Indices, PrimitiveTopology, VertexAttributeValues};
use block_mesh::ilattice::glam::Vec3A;
use block_mesh::ndshape::{ConstShape, ConstShape3u32};
use block_mesh::{
    greedy_quads, visible_block_faces, GreedyQuadsBuffer, MergeVoxel, UnitQuadBuffer, Voxel,
    VoxelVisibility, RIGHT_HANDED_Y_UP_CONFIG,
};
use super::*;


// References:
// https://0fps.net/2012/06/30/meshing-in-a-minecraft-game/
// https://github.com/bonsairobo/block-mesh-rs/blob/main/examples-crate/render/main.rs


// we define the size of a chunk as a cube of 256 * 256 * 256
// the total number of voxels in the cube needs to be smaller than a 2^32 anyway
const SIZE: u32 = 0x100;
type Chunk = ConstShape3u32<SIZE, SIZE, SIZE>;


// this function generate a trimesh from a matrix
pub fn generate_mesh(matrix: &Matrix<Label>, label: Label) -> Mesh {

    // prepare buffer of boolean voxels
    // fill it with true if the given label is present
    let mut voxels = [BoolVoxel(false); Chunk::SIZE as usize];
    for i in 0..Chunk::SIZE {
        let [x, y, z] = Chunk::delinearize(i);
        voxels[i as usize] = BoolVoxel(matrix.get(x as usize, y as usize, z as usize) == label);
    }

    // run the algorithm to find exposed faces
    let faces = RIGHT_HANDED_Y_UP_CONFIG.faces;
    let mut buffer = GreedyQuadsBuffer::new(voxels.len());
    greedy_quads(
        &voxels,       // buffer of voxels to analyze
        &Chunk {},     // chunk format
        [0; 3],        // TODO: starting point
        [SIZE - 1; 3], // TODO: end point
        &faces,        // order of vertices on the face
        &mut buffer    // output buffer
    );
    
    // prepare buffers to read data generated from the algorithm
    let num_quads = buffer.quads.num_quads();
    let num_verts = num_quads * 4;
    let mut gen_ind = Vec::with_capacity(num_quads * 6);
    let mut gen_pos = Vec::with_capacity(num_verts);
    let mut gen_nrm = Vec::with_capacity(num_verts);

    // fill the buffer with quads data
    for (group, face) in buffer.quads.groups.into_iter().zip(faces.into_iter()) {
        for quad in group.into_iter() {
            gen_ind.extend_from_slice(&face.quad_mesh_indices(gen_pos.len() as u32));
            gen_pos.extend_from_slice(&face.quad_mesh_positions(&quad, 1.0));
            gen_nrm.extend_from_slice(&face.quad_mesh_normals());
        }
    }

    // build the mesh from the buffers
    // TODO: this step will be done into an other function
    // we need to be able to serialize and deserialize the data generated by the algorithm
    // such that we can produce precomputed save files
    let mut mesh = Mesh::new(PrimitiveTopology::TriangleList);
    mesh.insert_attribute(Mesh::ATTRIBUTE_POSITION, gen_pos);
    mesh.insert_attribute(Mesh::ATTRIBUTE_NORMAL, gen_nrm);
    mesh.insert_attribute(Mesh::ATTRIBUTE_UV_0, vec![[0.0; 2]; num_verts]);
    mesh.set_indices(Some(Indices::U32(gen_ind)));
    mesh
}


// generic boolean voxel to be used with the algorithm
#[derive(Clone, Copy, Eq, PartialEq)]
struct BoolVoxel(bool);
impl Voxel for BoolVoxel {
    fn get_visibility(&self) -> VoxelVisibility {
        if self.0 {VoxelVisibility::Opaque} else {VoxelVisibility::Empty}
    }
}
impl MergeVoxel for BoolVoxel {
    type MergeValue = Self;
    fn merge_value(&self) -> Self::MergeValue {*self}
}
